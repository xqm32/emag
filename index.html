<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Osmos</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0a1a; }
canvas { display: block; cursor: none; }
#ui {
  position: fixed; top: 0; left: 0; width: 100%; pointer-events: none;
  display: flex; justify-content: space-between; padding: 18px 28px;
  font-family: 'Helvetica Neue', sans-serif; color: rgba(255,255,255,0.7); font-size: 14px;
  z-index: 10;
}
#ui > div { background: rgba(0,0,0,0.3); padding: 8px 16px; border-radius: 8px; }
#overlay {
  position: fixed; inset: 0; display: flex; flex-direction: column;
  align-items: center; justify-content: center; z-index: 20;
  background: rgba(6,6,20,0.88); font-family: 'Helvetica Neue', sans-serif; color: #ccc;
}
#overlay h1 { font-size: 52px; color: #fff; margin-bottom: 12px; letter-spacing: 6px; font-weight: 200; }
#overlay p { font-size: 15px; margin: 4px 0; line-height: 1.7; }
#overlay .sub { color: rgba(255,255,255,0.4); font-size: 12px; margin-top: 18px; }
#overlay button {
  margin-top: 28px; padding: 12px 48px; font-size: 16px; border: 1px solid rgba(255,255,255,0.25);
  background: rgba(255,255,255,0.07); color: #fff; border-radius: 30px; cursor: pointer;
  pointer-events: auto; transition: all 0.3s;
}
#overlay button:hover { background: rgba(255,255,255,0.15); }
.hidden { display: none !important; }
#timeControl {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  display: flex; gap: 8px; z-index: 10; pointer-events: auto;
}
#timeControl button {
  width: 36px; height: 36px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2);
  background: rgba(0,0,0,0.4); color: rgba(255,255,255,0.7); font-size: 14px;
  cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center;
}
#timeControl button:hover { background: rgba(255,255,255,0.15); }
#timeControl button.active { border-color: rgba(100,180,255,0.6); color: #fff; }
#speedLabel {
  position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
  color: rgba(255,255,255,0.4); font-size: 12px; font-family: 'Helvetica Neue', sans-serif;
  z-index: 10; pointer-events: none;
}
</style>
</head>
<body>
<div id="ui">
  <div id="massDisplay">质量: 0</div>
  <div id="rankDisplay">排名: 0/0</div>
</div>

<div id="timeControl">
  <button id="btnSlow" title="慢速">⏪</button>
  <button id="btnPause" title="暂停">⏸</button>
  <button id="btnNormal" class="active" title="正常">▶</button>
  <button id="btnFast" title="快速">⏩</button>
</div>
<div id="speedLabel">1.0x</div>

<div id="overlay">
  <h1>OSMOS</h1>
  <p>点击鼠标向反方向喷射质量来移动</p>
  <p>吞噬比你小的细胞，躲避比你大的</p>
  <p>成为最大的细胞即可获胜</p>
  <p class="sub">滚轮缩放 · 底部按钮调速 · R 重开</p>
  <button id="startBtn">开 始</button>
</div>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const massDisplay = document.getElementById('massDisplay');
const rankDisplay = document.getElementById('rankDisplay');
const speedLabel = document.getElementById('speedLabel');

let W, H;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Game state
const WORLD_R = 3000;
let cells = [];
let player = null;
let camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
let mouseX = W / 2, mouseY = H / 2;
let gameRunning = false;
let gameOver = false;
let gameWon = false;
let timeScale = 1;
let ejectCooldown = 0;
let particles = [];

// Time control
const speeds = [0.25, 0, 1, 2.5];
const speedBtns = [
  document.getElementById('btnSlow'),
  document.getElementById('btnPause'),
  document.getElementById('btnNormal'),
  document.getElementById('btnFast'),
];
function setSpeed(idx) {
  timeScale = speeds[idx];
  speedBtns.forEach((b, i) => b.classList.toggle('active', i === idx));
  speedLabel.textContent = timeScale === 0 ? '暂停' : timeScale + 'x';
}
speedBtns.forEach((b, i) => b.addEventListener('click', () => setSpeed(i)));

function massToRadius(mass) {
  return Math.sqrt(mass / Math.PI);
}

function radiusToMass(r) {
  return Math.PI * r * r;
}

function hsl(h, s, l, a = 1) {
  return `hsla(${h},${s}%,${l}%,${a})`;
}

class Cell {
  constructor(x, y, mass, isPlayer = false) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.mass = mass;
    this.isPlayer = isPlayer;
    this.alive = true;
    this.hue = isPlayer ? 200 : Math.random() * 360;
    this.saturation = isPlayer ? 70 : 40 + Math.random() * 30;
    this.lightness = isPlayer ? 55 : 35 + Math.random() * 25;
    this.pulsePhase = Math.random() * Math.PI * 2;
    // AI
    this.aiTimer = Math.random() * 2;
    this.aiTarget = null;
  }

  get radius() { return massToRadius(this.mass); }

  update(dt) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    // Friction
    const friction = 0.998;
    this.vx *= Math.pow(friction, dt * 60);
    this.vy *= Math.pow(friction, dt * 60);
    // World boundary - soft bounce
    const r = this.radius;
    const dist = Math.sqrt(this.x * this.x + this.y * this.y);
    if (dist + r > WORLD_R) {
      const nx = this.x / dist;
      const ny = this.y / dist;
      const overlap = dist + r - WORLD_R;
      this.x -= nx * overlap * 0.5;
      this.y -= ny * overlap * 0.5;
      const dot = this.vx * nx + this.vy * ny;
      if (dot > 0) {
        this.vx -= nx * dot * 1.5;
        this.vy -= ny * dot * 1.5;
      }
    }
    this.pulsePhase += dt * 2;
  }

  aiUpdate(dt, allCells) {
    if (this.isPlayer || !this.alive) return;
    this.aiTimer -= dt;
    if (this.aiTimer > 0) return;
    this.aiTimer = 0.5 + Math.random() * 1.5;

    let nearestSmaller = null, nearestLarger = null;
    let dSmall = Infinity, dLarge = Infinity;

    for (const c of allCells) {
      if (c === this || !c.alive) continue;
      const dx = c.x - this.x;
      const dy = c.y - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (c.mass < this.mass * 0.8 && dist < dSmall) {
        dSmall = dist;
        nearestSmaller = c;
      }
      if (c.mass > this.mass * 1.3 && dist < dLarge) {
        dLarge = dist;
        nearestLarger = c;
      }
    }

    // Flee from larger if close
    if (nearestLarger && dLarge < this.radius * 8) {
      const dx = this.x - nearestLarger.x;
      const dy = this.y - nearestLarger.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      this.ejectMass(this.x - dx / dist * 100, this.y - dy / dist * 100);
    }
    // Chase smaller if nearby
    else if (nearestSmaller && dSmall < this.radius * 12) {
      this.ejectMass(this.x - (nearestSmaller.x - this.x), this.y - (nearestSmaller.y - this.y));
    }
  }

  ejectMass(targetX, targetY) {
    if (this.mass < 5) return;
    const dx = targetX - this.x;
    const dy = targetY - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    const nx = dx / dist;
    const ny = dy / dist;

    const ejectMass = this.mass * 0.012;
    this.mass -= ejectMass;

    const speed = 250;
    this.vx -= nx * speed * ejectMass / this.mass;
    this.vy -= ny * speed * ejectMass / this.mass;

    // Create ejected particle
    particles.push({
      x: this.x + nx * this.radius,
      y: this.y + ny * this.radius,
      vx: nx * speed + this.vx,
      vy: ny * speed + this.vy,
      mass: ejectMass,
      radius: massToRadius(ejectMass),
      life: 1,
      hue: this.hue,
      saturation: this.saturation,
      lightness: this.lightness + 15,
    });
  }

  draw(ctx) {
    const r = this.radius;
    const pulse = 1 + Math.sin(this.pulsePhase) * 0.02;
    const drawR = r * pulse;

    // Glow
    const grad = ctx.createRadialGradient(this.x, this.y, drawR * 0.2, this.x, this.y, drawR * 1.5);
    const baseAlpha = this.isPlayer ? 0.35 : 0.2;
    grad.addColorStop(0, hsl(this.hue, this.saturation, this.lightness, baseAlpha));
    grad.addColorStop(1, hsl(this.hue, this.saturation, this.lightness, 0));
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(this.x, this.y, drawR * 1.5, 0, Math.PI * 2);
    ctx.fill();

    // Body
    const bodyGrad = ctx.createRadialGradient(
      this.x - drawR * 0.3, this.y - drawR * 0.3, drawR * 0.1,
      this.x, this.y, drawR
    );
    bodyGrad.addColorStop(0, hsl(this.hue, this.saturation, this.lightness + 20, 0.9));
    bodyGrad.addColorStop(0.7, hsl(this.hue, this.saturation, this.lightness, 0.8));
    bodyGrad.addColorStop(1, hsl(this.hue, this.saturation, this.lightness - 10, 0.6));
    ctx.fillStyle = bodyGrad;
    ctx.beginPath();
    ctx.arc(this.x, this.y, drawR, 0, Math.PI * 2);
    ctx.fill();

    // Border
    ctx.strokeStyle = hsl(this.hue, this.saturation, this.lightness + 10, 0.4);
    ctx.lineWidth = this.isPlayer ? 2 : 1;
    ctx.stroke();

    // Inner highlight
    if (drawR > 8) {
      ctx.fillStyle = hsl(this.hue, this.saturation - 10, this.lightness + 30, 0.15);
      ctx.beginPath();
      ctx.arc(this.x - drawR * 0.25, this.y - drawR * 0.25, drawR * 0.4, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

function spawnCells() {
  cells = [];
  particles = [];

  // Player
  player = new Cell(0, 0, 80, true);
  cells.push(player);

  // Other cells - varying sizes
  const count = 120;
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 200 + Math.random() * (WORLD_R - 400);
    const x = Math.cos(angle) * dist;
    const y = Math.sin(angle) * dist;

    // Mass distribution: many small, some medium, few large
    let mass;
    const r = Math.random();
    if (r < 0.5) mass = 3 + Math.random() * 30;        // small
    else if (r < 0.8) mass = 30 + Math.random() * 80;   // medium
    else if (r < 0.95) mass = 80 + Math.random() * 200;  // large
    else mass = 200 + Math.random() * 400;                // huge

    const cell = new Cell(x, y, mass);
    cell.vx = (Math.random() - 0.5) * 20;
    cell.vy = (Math.random() - 0.5) * 20;
    cells.push(cell);
  }
}

function checkCollisions() {
  for (let i = 0; i < cells.length; i++) {
    if (!cells[i].alive) continue;
    for (let j = i + 1; j < cells.length; j++) {
      if (!cells[j].alive) continue;

      const dx = cells[j].x - cells[i].x;
      const dy = cells[j].y - cells[i].y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const r1 = cells[i].radius;
      const r2 = cells[j].radius;

      if (dist < r1 + r2) {
        // The larger absorbs the smaller
        let bigger, smaller;
        if (cells[i].mass >= cells[j].mass) {
          bigger = cells[i]; smaller = cells[j];
        } else {
          bigger = cells[j]; smaller = cells[i];
        }

        // Only absorb if significantly overlapping
        if (dist < bigger.radius) {
          // Absorb
          const ratio = smaller.mass / bigger.mass;
          bigger.mass += smaller.mass * 0.9;
          // Momentum conservation
          bigger.vx = (bigger.vx * (1 - ratio) + smaller.vx * ratio);
          bigger.vy = (bigger.vy * (1 - ratio) + smaller.vy * ratio);
          smaller.alive = false;

          // Absorb particles for effect
          for (let k = 0; k < Math.min(5, smaller.radius); k++) {
            const angle = Math.random() * Math.PI * 2;
            particles.push({
              x: smaller.x, y: smaller.y,
              vx: Math.cos(angle) * 50 + bigger.vx,
              vy: Math.sin(angle) * 50 + bigger.vy,
              mass: 0.5, radius: 2,
              life: 0.5,
              hue: smaller.hue, saturation: smaller.saturation, lightness: smaller.lightness + 20,
            });
          }
        } else if (dist < r1 + r2 - Math.min(r1, r2) * 0.3) {
          // Gradual absorption
          const rate = 0.02;
          const transfer = smaller.mass * rate;
          bigger.mass += transfer * 0.9;
          smaller.mass -= transfer;
          if (smaller.mass < 1) smaller.alive = false;
        }
      }
    }
  }

  // Particle absorption
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    for (const c of cells) {
      if (!c.alive) continue;
      const dx = c.x - p.x;
      const dy = c.y - p.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < c.radius * 0.8) {
        c.mass += p.mass * 0.5;
        particles.splice(i, 1);
        break;
      }
    }
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= 0.98;
    p.vy *= 0.98;
    p.life -= dt * 0.3;
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}

function drawParticles(ctx) {
  for (const p of particles) {
    const alpha = Math.max(0, p.life);
    ctx.fillStyle = hsl(p.hue, p.saturation, p.lightness, alpha * 0.7);
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius * alpha, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawBackground(ctx) {
  // Dark background
  ctx.fillStyle = '#06060f';
  ctx.fillRect(0, 0, W, H);

  ctx.save();
  ctx.translate(W / 2, H / 2);
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(-camera.x, -camera.y);

  // World boundary circle
  ctx.strokeStyle = 'rgba(40, 60, 120, 0.15)';
  ctx.lineWidth = 3 / camera.zoom;
  ctx.beginPath();
  ctx.arc(0, 0, WORLD_R, 0, Math.PI * 2);
  ctx.stroke();

  // Grid
  const gridSize = 200;
  ctx.strokeStyle = 'rgba(30, 40, 80, 0.08)';
  ctx.lineWidth = 1 / camera.zoom;
  const viewR = WORLD_R + 200;
  for (let x = -viewR; x <= viewR; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, -viewR);
    ctx.lineTo(x, viewR);
    ctx.stroke();
  }
  for (let y = -viewR; y <= viewR; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(-viewR, y);
    ctx.lineTo(viewR, y);
    ctx.stroke();
  }

  ctx.restore();
}

function drawCursor(ctx) {
  if (!gameRunning || gameOver) return;
  // Direction indicator from player
  ctx.save();
  ctx.translate(W / 2, H / 2);
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(-camera.x, -camera.y);

  const dx = (mouseX - W / 2) / camera.zoom + camera.x - player.x;
  const dy = (mouseY - H / 2) / camera.zoom + camera.y - player.y;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
  const nx = dx / dist;
  const ny = dy / dist;

  // Draw trajectory hint (opposite direction)
  const pr = player.radius;
  ctx.strokeStyle = 'rgba(100, 180, 255, 0.2)';
  ctx.lineWidth = 2 / camera.zoom;
  ctx.setLineDash([5 / camera.zoom, 5 / camera.zoom]);
  ctx.beginPath();
  ctx.moveTo(player.x - nx * pr * 1.2, player.y - ny * pr * 1.2);
  ctx.lineTo(player.x - nx * pr * 3, player.y - ny * pr * 3);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.restore();

  // Crosshair at mouse
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1;
  const s = 10;
  ctx.beginPath();
  ctx.moveTo(mouseX - s, mouseY); ctx.lineTo(mouseX + s, mouseY);
  ctx.moveTo(mouseX, mouseY - s); ctx.lineTo(mouseX, mouseY + s);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(mouseX, mouseY, 4, 0, Math.PI * 2);
  ctx.stroke();
}

function updateCamera(dt) {
  if (!player || !player.alive) return;
  // Smooth follow
  const smoothing = 1 - Math.pow(0.05, dt);
  camera.x += (player.x - camera.x) * smoothing;
  camera.y += (player.y - camera.y) * smoothing;

  // Auto zoom based on player size
  const desiredZoom = Math.max(0.15, Math.min(2, 30 / player.radius));
  camera.targetZoom = desiredZoom;
  camera.zoom += (camera.targetZoom - camera.zoom) * smoothing * 0.5;
}

function updateUI() {
  if (!player) return;
  massDisplay.textContent = `质量: ${Math.floor(player.mass)}`;
  const alive = cells.filter(c => c.alive);
  alive.sort((a, b) => b.mass - a.mass);
  const rank = alive.indexOf(player) + 1;
  rankDisplay.textContent = `排名: ${rank}/${alive.length}`;
}

function checkWinLose() {
  if (!player.alive) {
    gameOver = true;
    gameWon = false;
    showOverlay('你被吞噬了！', false);
    return;
  }
  const alive = cells.filter(c => c.alive && !c.isPlayer);
  if (alive.length === 0 || (alive.length > 0 && alive.every(c => c.mass < player.mass * 0.3))) {
    const allSmaller = alive.every(c => c.mass < player.mass);
    if (allSmaller && player.mass > 500) {
      gameOver = true;
      gameWon = true;
      showOverlay('你赢了！', true);
    }
  }
}

function showOverlay(msg, won) {
  overlay.classList.remove('hidden');
  overlay.querySelector('h1').textContent = msg;
  overlay.querySelector('p').textContent = won ? '你成功吞噬了所有对手！' : '你的细胞已被吸收...';
  overlay.querySelectorAll('p')[1].textContent = '';
  overlay.querySelectorAll('p')[2].textContent = '';
  const sub = overlay.querySelector('.sub');
  sub.textContent = '';
  startBtn.textContent = '再来一局';
}

let lastTime = 0;
function gameLoop(time) {
  requestAnimationFrame(gameLoop);
  const rawDt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;

  if (!gameRunning || gameOver) {
    drawBackground(ctx);
    if (cells.length > 0) {
      ctx.save();
      ctx.translate(W / 2, H / 2);
      ctx.scale(camera.zoom, camera.zoom);
      ctx.translate(-camera.x, -camera.y);
      cells.filter(c => c.alive).forEach(c => c.draw(ctx));
      drawParticles(ctx);
      ctx.restore();
    }
    return;
  }

  const dt = rawDt * timeScale;

  // Eject cooldown
  ejectCooldown = Math.max(0, ejectCooldown - rawDt);

  // Update cells
  for (const c of cells) {
    if (!c.alive) continue;
    c.update(dt);
    c.aiUpdate(dt, cells);
  }

  updateParticles(dt);
  checkCollisions();

  // Remove dead cells
  // cells = cells.filter(c => c.alive); // keep for ranking

  updateCamera(rawDt); // Camera always smooth

  // Draw
  drawBackground(ctx);

  ctx.save();
  ctx.translate(W / 2, H / 2);
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(-camera.x, -camera.y);

  // Draw cells sorted by size (small on top)
  const alive = cells.filter(c => c.alive);
  alive.sort((a, b) => b.mass - a.mass);

  // Draw size comparison indicators
  if (player.alive) {
    for (const c of alive) {
      if (c === player) continue;
      const r = c.radius;
      if (r < 3) continue;
      // Color ring: blue=smaller (edible), red=larger (danger)
      if (c.mass < player.mass * 0.95) {
        ctx.strokeStyle = 'rgba(80, 180, 255, 0.15)';
      } else if (c.mass > player.mass * 1.05) {
        ctx.strokeStyle = 'rgba(255, 80, 80, 0.15)';
      } else {
        ctx.strokeStyle = 'rgba(255, 255, 100, 0.15)';
      }
      ctx.lineWidth = Math.max(2, r * 0.08);
      ctx.beginPath();
      ctx.arc(c.x, c.y, r + ctx.lineWidth, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  drawParticles(ctx);

  for (const c of alive) {
    c.draw(ctx);
  }

  ctx.restore();

  drawCursor(ctx);
  updateUI();
  checkWinLose();
}

// Input
canvas.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
});

canvas.addEventListener('mousedown', (e) => {
  if (!gameRunning || gameOver || !player.alive) return;
  if (timeScale === 0) return;
  // Convert mouse to world coords
  const worldX = (e.clientX - W / 2) / camera.zoom + camera.x;
  const worldY = (e.clientY - H / 2) / camera.zoom + camera.y;
  player.ejectMass(worldX, worldY);
});

// Continuous ejection on hold
let mouseDown = false;
canvas.addEventListener('mousedown', () => { mouseDown = true; });
canvas.addEventListener('mouseup', () => { mouseDown = false; });
canvas.addEventListener('mouseleave', () => { mouseDown = false; });

setInterval(() => {
  if (mouseDown && gameRunning && !gameOver && player && player.alive && timeScale > 0) {
    const worldX = (mouseX - W / 2) / camera.zoom + camera.x;
    const worldY = (mouseY - H / 2) / camera.zoom + camera.y;
    player.ejectMass(worldX, worldY);
  }
}, 80);

// Scroll to zoom
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const factor = e.deltaY > 0 ? 0.9 : 1.1;
  camera.targetZoom = Math.max(0.05, Math.min(3, camera.targetZoom * factor));
}, { passive: false });

// Keyboard
document.addEventListener('keydown', (e) => {
  if (e.key === 'r' || e.key === 'R') {
    startGame();
  }
  if (e.key === ' ') {
    e.preventDefault();
    if (timeScale === 0) setSpeed(2);
    else setSpeed(1);
  }
});

function startGame() {
  gameOver = false;
  gameRunning = true;
  overlay.classList.add('hidden');
  setSpeed(2);
  spawnCells();
  camera.x = player.x;
  camera.y = player.y;
  camera.zoom = 1;
  camera.targetZoom = 1;
}

startBtn.addEventListener('click', startGame);

// Init
spawnCells();
camera.zoom = 0.3;
camera.targetZoom = 0.3;
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
